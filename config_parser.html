<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Speeduino INI Parser</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
      }

      body {
        font-family: "Inter", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        margin: 0;
        padding: 0;
      }

      /* Glass morphism background */
      .glass-bg {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 20px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      }

      /* Modern scrollbar styling */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 4px;
      }
      ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.3);
        border-radius: 4px;
        transition: background 0.3s ease;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.5);
      }

      /* Animations */
      .fade-in {
        animation: fadeIn 0.5s ease-in;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-up {
        animation: slideUp 0.6s cubic-bezier(0.4, 0, 0.2, 1);
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(50px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Button improvements */
      .btn-primary {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        border: none;
        color: white;
        font-weight: 600;
        padding: 12px 24px;
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .btn-primary:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 24px rgba(102, 126, 234, 0.4);
      }

      .btn-primary:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: white;
        font-weight: 500;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.3s ease;
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-1px);
      }

      /* Input improvements */
      .modern-input {
        background: rgba(255, 255, 255, 0.9);
        border: 2px solid transparent;
        border-radius: 12px;
        transition: all 0.3s ease;
        backdrop-filter: blur(10px);
      }

      .modern-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        background: white;
      }

      /* Drag and drop styling */
      .drag-drop-area {
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 12px;
        padding: 2rem;
        text-align: center;
        transition: all 0.3s ease;
        cursor: pointer;
        background: rgba(255, 255, 255, 0.05);
      }

      .drag-drop-area.drag-over {
        border-color: #667eea;
        background: rgba(102, 126, 234, 0.1);
        transform: scale(1.02);
      }

      .drag-drop-area:hover {
        border-color: rgba(255, 255, 255, 0.5);
        background: rgba(255, 255, 255, 0.1);
      }

      /* Search box for JSON */
      .search-container {
        position: relative;
        margin-bottom: 1rem;
      }

      .search-input {
        width: 100%;
        padding: 10px 40px 10px 16px;
        background: rgba(255, 255, 255, 0.95);
        border: 2px solid transparent;
        border-radius: 25px;
        font-size: 14px;
        color: #1f2937; /* Dark grey text */
        font-weight: 500;
        transition: all 0.3s ease;
      }

      .search-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        background: white;
        color: #111827; /* Darker text on focus */
      }

      .search-input::placeholder {
        color: #6b7280; /* Medium grey for placeholder */
        font-weight: 400;
      }

      .search-icon {
        position: absolute;
        right: 14px;
        top: 50%;
        transform: translateY(-50%);
        color: #4b5563; /* Darker grey for icon */
        pointer-events: none;
        font-size: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
      }

      /* Search Navigation */
      .search-navigation {
        margin-top: 0.5rem;
        padding: 0.5rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 8px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .search-navigation.hidden {
        display: none;
      }

      /* Search Highlighting */
      .search-highlight {
        background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        color: #000;
        padding: 1px 2px;
        border-radius: 3px;
        font-weight: 600;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
        border: 1px solid rgba(245, 158, 11, 0.3);
      }

      .search-current {
        background: linear-gradient(
          135deg,
          #ef4444 0%,
          #dc2626 100%
        ) !important;
        color: white !important;
        padding: 2px 4px !important;
        border-radius: 4px !important;
        font-weight: 700 !important;
        box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4) !important;
        border: 2px solid #fca5a5 !important;
        animation: pulse-highlight 2s ease-in-out;
      }

      @keyframes pulse-highlight {
        0%,
        100% {
          box-shadow: 0 2px 8px rgba(239, 68, 68, 0.4);
        }
        50% {
          box-shadow: 0 4px 16px rgba(239, 68, 68, 0.6);
        }
      }

      /* Search counter styling */
      #searchCounter {
        background: rgba(255, 255, 255, 0.1);
        padding: 2px 8px;
        border-radius: 12px;
        font-weight: 500;
        min-width: 60px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      /* Navigation buttons */
      #prevResult,
      #nextResult {
        min-width: 28px;
        height: 28px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 14px;
      }

      #prevResult:hover,
      #nextResult:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
      }

      /* Improved focus for search results */
      .json-node:has(.search-current) {
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.2);
        border-radius: 6px;
        padding: 4px;
        margin: 2px 0;
      }

      /* High contrast mode improvements */
      @media (prefers-contrast: high) {
        .search-highlight {
          background: #ffff00 !important;
          color: #000000 !important;
          border: 2px solid #000000 !important;
        }

        .search-current {
          background: #ff0000 !important;
          color: #ffffff !important;
          border: 3px solid #ffffff !important;
        }

        .status-success {
          background: #00ff00 !important;
          color: #000000 !important;
          border: 2px solid #000000 !important;
          font-weight: 700 !important;
        }

        .status-error {
          background: #ff0000 !important;
          color: #ffffff !important;
          border: 2px solid #ffffff !important;
          font-weight: 700 !important;
        }

        .status-processing {
          background: #0066ff !important;
          color: #ffffff !important;
          border: 2px solid #ffffff !important;
          font-weight: 700 !important;
        }
      }

      /* Tooltip */
      .tooltip {
        position: relative;
        display: inline-block;
      }

      .tooltip .tooltip-text {
        visibility: hidden;
        width: 200px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        text-align: center;
        border-radius: 8px;
        padding: 8px;
        position: absolute;
        z-index: 1000;
        bottom: 125%;
        left: 50%;
        margin-left: -100px;
        opacity: 0;
        transition: opacity 0.3s;
        font-size: 12px;
        backdrop-filter: blur(10px);
      }

      .tooltip:hover .tooltip-text {
        visibility: visible;
        opacity: 1;
      }

      /* Status indicators */
      .status-indicator {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 6px 12px;
        border-radius: 20px;
        font-size: 12px;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }

      .status-success {
        background: rgba(34, 197, 94, 0.15);
        color: #065f46; /* Much darker green for better contrast */
        border: 1px solid rgba(34, 197, 94, 0.3);
        font-weight: 600;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
      }

      .status-error {
        background: rgba(239, 68, 68, 0.15);
        color: #7f1d1d; /* Much darker red for better contrast */
        border: 1px solid rgba(239, 68, 68, 0.3);
        font-weight: 600;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
      }

      .status-processing {
        background: rgba(59, 130, 246, 0.15);
        color: #1e3a8a; /* Much darker blue for better contrast */
        border: 1px solid rgba(59, 130, 246, 0.3);
        font-weight: 600;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.1);
      }

      /* Modern progress bar */
      .progress-container {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        overflow: hidden;
        height: 8px;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        border-radius: 10px;
        transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .progress-bar::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(255, 255, 255, 0.3),
          transparent
        );
        animation: shimmer 2s infinite;
      }

      @keyframes shimmer {
        0% {
          transform: translateX(-100%);
        }
        100% {
          transform: translateX(100%);
        }
      }

      /* Stats cards */
      .stats-card {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        padding: 1rem;
        text-align: center;
        color: white;
      }

      .stats-number {
        font-size: 1.5rem;
        font-weight: 700;
        color: #fbbf24;
      }

      .stats-label {
        font-size: 0.75rem;
        opacity: 0.8;
        text-transform: uppercase;
        letter-spacing: 0.5px;
      }
      /* Styling for JSON Tree View */
      .json-viewer {
        font-family: "Menlo", "Monaco", "Consolas", monospace;
        font-size: 0.875rem;
        line-height: 1.5;
        color: #374151;
        background: #ffffff;
        border-radius: 0.5rem;
        padding: 1rem;
      }

      .json-node {
        position: relative;
        margin: 0;
        padding: 0;
      }

      .json-node-content {
        display: flex;
        align-items: center;
        padding: 2px 0;
        border-radius: 3px;
        transition: background-color 0.15s ease;
      }

      .json-node-content:hover {
        background-color: #f8fafc;
      }

      .json-toggle {
        width: 12px;
        height: 12px;
        margin-right: 6px;
        cursor: pointer;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        font-size: 10px;
        color: #6b7280;
        user-select: none;
        flex-shrink: 0;
      }

      .json-toggle:hover {
        color: #374151;
      }

      .json-toggle.expanded::before {
        content: "‚ñº";
      }

      .json-toggle.collapsed::before {
        content: "‚ñ∂";
      }

      .json-toggle.leaf::before {
        content: "";
      }

      .json-key {
        color: #7c3aed; /* Purple-600 */
        font-weight: 500;
        margin-right: 4px;
      }

      .json-separator {
        color: #6b7280;
        margin-right: 4px;
      }

      .json-value {
        font-weight: 400;
      }

      .json-value.string {
        color: #059669; /* Emerald-600 */
      }

      .json-value.number {
        color: #2563eb; /* Blue-600 */
      }

      .json-value.boolean {
        color: #dc2626; /* Red-600 */
      }

      .json-value.null {
        color: #6b7280; /* Gray-500 */
        font-style: italic;
      }

      .json-bracket {
        color: #f59e0b; /* Amber-500 */
        font-weight: 500;
        font-style: italic;
      }

      .json-count {
        color: #f97316; /* Orange-500 */
        font-size: 0.8em;
        margin-left: 4px;
        font-weight: 500;
      }

      .json-children {
        margin-left: 16px;
        border-left: 1px solid #d1d5db;
        padding-left: 8px;
        display: none;
        position: relative;
      }

      .json-children::before {
        content: "";
        position: absolute;
        left: -1px;
        top: 0;
        bottom: 0;
        border-left: 1px solid #d1d5db;
      }

      .json-children.expanded {
        display: block;
      }

      .json-array-index {
        color: #6366f1; /* Indigo-500 */
        font-weight: 500;
        margin-right: 4px;
      }

      /* Responsive Design */
      @media (max-width: 1280px) {
        .container {
          padding: 1rem;
        }

        .glass-bg {
          padding: 1rem;
        }

        .grid-cols-3 {
          grid-template-columns: 1fr;
          gap: 1rem;
        }
      }

      @media (max-width: 768px) {
        .stats-card {
          padding: 0.75rem;
        }

        .stats-number {
          font-size: 1.25rem;
        }

        .btn-primary,
        .btn-secondary {
          padding: 10px 16px;
          font-size: 0.875rem;
        }

        .search-input {
          font-size: 16px; /* Prevent zoom on iOS */
          color: #1f2937; /* Maintain dark text on mobile */
        }

        .search-input:focus {
          color: #111827; /* Darker text on focus for mobile */
        }

        .search-icon {
          right: 12px;
          font-size: 14px;
          width: 18px;
          height: 18px;
        }

        .modern-input {
          font-size: 16px; /* Prevent zoom on iOS */
        }

        .search-navigation {
          padding: 0.25rem;
        }

        #searchCounter {
          font-size: 10px;
          min-width: 40px;
        }

        #prevResult,
        #nextResult {
          min-width: 24px;
          height: 24px;
          font-size: 12px;
        }

        #jsonOutput {
          height: 300px !important;
        }

        .grid.grid-cols-1.xl\\:grid-cols-2 {
          gap: 1rem;
        }
      }

      @media (max-width: 640px) {
        .container {
          padding: 0.5rem;
        }

        .flex-wrap .btn-secondary {
          flex: 1;
          min-width: 0;
        }

        .tooltip .tooltip-text {
          width: 150px;
          margin-left: -75px;
          font-size: 10px;
        }

        .status-indicator {
          font-size: 10px;
          padding: 4px 8px;
        }

        .status-success {
          color: #064e3b; /* Even darker green for mobile */
          font-weight: 700;
        }

        .status-error {
          color: #7c2d12; /* Even darker red for mobile */
          font-weight: 700;
        }

        .status-processing {
          color: #1e40af; /* Even darker blue for mobile */
          font-weight: 700;
        }
      }

      /* Focus styles for accessibility */
      .btn-primary:focus,
      .btn-secondary:focus,
      .modern-input:focus,
      .search-input:focus {
        outline: 2px solid #fbbf24;
        outline-offset: 2px;
      }

      /* Loading animation improvements */
      .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      /* Dark mode styles */
      .dark-mode {
        --glass-bg: rgba(31, 41, 55, 0.3);
        --text-primary: #f9fafb;
        --text-secondary: rgba(249, 250, 251, 0.8);
      }

      /* High contrast mode */
      @media (prefers-contrast: high) {
        .glass-bg {
          background: rgba(255, 255, 255, 0.95);
          color: #000;
        }

        .btn-secondary {
          background: rgba(255, 255, 255, 0.9);
          color: #000;
        }
      }

      /* Reduced motion */
      @media (prefers-reduced-motion: reduce) {
        *,
        *::before,
        *::after {
          animation-duration: 0.01ms !important;
          animation-iteration-count: 1 !important;
          transition-duration: 0.01ms !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="container mx-auto p-4 md:p-8">
      <header class="text-center mb-8 fade-in">
        <div class="glass-bg p-8 mb-6">
          <h1 class="text-4xl md:text-5xl font-bold text-white mb-4">
            <span
              class="bg-gradient-to-r from-yellow-400 to-orange-500 bg-clip-text text-transparent"
            >
              Speeduino INI
            </span>
            <span class="text-white">Parser</span>
          </h1>
          <p class="text-lg text-white/80 max-w-2xl mx-auto leading-relaxed">
            Transform your Speeduino configuration files into beautiful,
            interactive JSON trees. Drag & drop, paste, or upload your
            <code>.ini</code> files.
          </p>

          <!-- Stats Row -->
          <div class="grid grid-cols-3 gap-4 mt-6 max-w-md mx-auto">
            <div class="stats-card">
              <div class="stats-number" id="files-processed">0</div>
              <div class="stats-label">Files Processed</div>
            </div>
            <div class="stats-card">
              <div class="stats-number" id="total-keys">0</div>
              <div class="stats-label">Total Keys</div>
            </div>
            <div class="stats-card">
              <div class="stats-number" id="parse-time">0ms</div>
              <div class="stats-label">Parse Time</div>
            </div>
          </div>
        </div>
      </header>

      <main class="grid grid-cols-1 xl:grid-cols-2 gap-8">
        <!-- Input Area -->
        <div class="glass-bg p-6 slide-up">
          <div class="flex items-center justify-between mb-6">
            <h2
              class="text-2xl font-semibold text-white flex items-center gap-3"
            >
              <span class="text-2xl">üìù</span>
              Configuration Input
            </h2>
            <div
              class="status-indicator status-processing"
              id="input-status"
              style="display: none"
            >
              <span
                class="w-2 h-2 bg-current rounded-full animate-pulse"
              ></span>
              Ready
            </div>
          </div>

          <!-- Drag & Drop Area -->
          <div class="drag-drop-area mb-4" id="dragDropArea">
            <div class="text-white/70 mb-2">
              <span class="text-4xl mb-3 block">üìÅ</span>
              <p class="text-lg font-medium">Drag & Drop your .ini file here</p>
              <p class="text-sm opacity-75">or click to browse</p>
            </div>
          </div>

          <div class="relative">
            <textarea
              id="iniInput"
              class="w-full h-96 lg:h-[500px] p-4 modern-input font-mono text-sm resize-none"
              placeholder="Paste your .ini file content here, or use drag & drop above..."
            ></textarea>

            <!-- Character count -->
            <div
              class="absolute bottom-2 right-2 text-xs text-gray-500 bg-white/80 px-2 py-1 rounded"
              id="char-count"
            >
              0 characters
            </div>
          </div>

          <!-- Hidden file input -->
          <input
            type="file"
            id="fileInput"
            accept=".ini,.txt"
            class="hidden"
            multiple
          />

          <div class="mt-6 flex gap-2 items-center">
            <div class="tooltip">
              <button id="clearButton" class="btn-secondary text-xs py-3 px-4">
                üóëÔ∏è
              </button>
              <span class="tooltip-text">Clear current content</span>
            </div>
            <div class="tooltip flex-1">
              <button id="parseButton" class="btn-primary w-full py-3 px-4">
                ‚ö° Parse Configuration
              </button>
              <span class="tooltip-text"
                >Transform your .ini file into JSON tree</span
              >
            </div>
          </div>
        </div>

        <!-- Output Area -->
        <div class="glass-bg text-white p-6 flex flex-col slide-up">
          <div class="flex justify-between items-center mb-6 flex-wrap gap-2">
            <h2
              class="text-2xl font-semibold text-white flex items-center gap-3"
            >
              <span class="text-2xl">üå≥</span>
              JSON Tree Viewer
            </h2>
            <div
              class="status-indicator status-success"
              id="output-status"
              style="display: none"
            >
              <span class="w-2 h-2 bg-current rounded-full"></span>
              Parsed Successfully
            </div>
          </div>

          <!-- Search and Controls -->
          <div class="mb-4 space-y-3">
            <!-- Search Box -->
            <div class="search-container">
              <input
                type="text"
                id="searchInput"
                class="search-input"
                placeholder="Search in JSON tree... (Enter: next, Shift+Enter: prev, Esc: clear)"
                disabled
              />
              <div class="search-icon" title="Search">üîç</div>
            </div>

            <!-- Control Buttons -->
            <div class="flex items-center gap-2 flex-wrap">
              <div class="tooltip">
                <button
                  id="expandButton"
                  class="btn-secondary text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  üìÇ Expand All
                </button>
                <span class="tooltip-text">Expand all JSON nodes</span>
              </div>
              <div class="tooltip">
                <button
                  id="collapseButton"
                  class="btn-secondary text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  üìÅ Collapse All
                </button>
                <span class="tooltip-text">Collapse all JSON nodes</span>
              </div>
              <div class="tooltip">
                <button
                  id="copyButton"
                  class="btn-secondary text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  üìã Copy JSON
                </button>
                <span class="tooltip-text">Copy raw JSON to clipboard</span>
              </div>
              <div class="tooltip">
                <button
                  id="downloadButton"
                  class="btn-secondary text-sm py-2 px-3 disabled:opacity-50 disabled:cursor-not-allowed"
                  disabled
                >
                  üíæ Download
                </button>
                <span class="tooltip-text">Download JSON file</span>
              </div>
            </div>
          </div>

          <!-- Loading State -->
          <div id="spinner" class="hidden text-center py-10">
            <div class="relative">
              <svg
                class="animate-spin h-12 w-12 text-white mx-auto mb-4"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
            </div>
            <p id="progress-text" class="mt-2 text-white font-medium">
              Parsing...
            </p>
            <div class="mt-4 w-full max-w-xs mx-auto">
              <div
                class="progress-container"
                id="progress-bar"
                style="display: none"
              >
                <div
                  class="progress-bar"
                  id="progress-fill"
                  style="width: 0%"
                ></div>
              </div>
            </div>
          </div>

          <!-- JSON Output -->
          <div
            id="jsonOutput"
            class="flex-grow w-full h-96 lg:h-[500px] p-4 bg-black/20 backdrop-blur-sm border border-white/10 rounded-xl overflow-auto text-sm"
            style="color: #e5e7eb"
          ></div>

          <!-- Footer Info -->
          <div
            class="mt-4 flex justify-between items-center text-xs text-white/60"
          >
            <span
              >Shortcuts: Ctrl+F (Search), Ctrl+E (Expand), Ctrl+R (Collapse) |
              In Search: Enter (Next), Shift+Enter (Prev), Esc (Clear)</span
            >
            <span id="node-count">0 nodes</span>
          </div>
        </div>
      </main>
    </div>

    <script>
      // ===================================================================================
      // Speeduino INI Parser Logic
      // ===================================================================================
      class SpeeduinoIniParser {
        constructor() {
          this.defines = {};
          this.config = {};
          this.flags = {
            LAMBDA: false,
            CELSIUS: true,
            mcu_stm32: false,
            mcu_teensy: false,
            COMMS_COMPAT: false,
            resetcontrol_adv: false,
            MSDROID_COMPAT: false,
            enablehardware_test: false,
            pressure_bar: false,
          };
          // State for complex sections
          this.currentSection = null;
          this.currentUserDefinedDialog = null;
          this.lastUserDefinedElement = null;
          this.currentCurve = null;
          this.currentTable = null;
          this.currentGaugeCategory = "Default";
          this.currentLogger = null;
          this.currentReferenceTable = null;
        }

        splitRespectingQuotes(str, delimiter = ",") {
          return (
            str.match(
              new RegExp(`(?:[^{"${delimiter}]+|\\{[^}]*\\}|"[^"]*")+`, "g")
            ) || []
          )
            .map((p) => p.trim())
            .filter((p) => p.length > 0);
        }

        splitValueAndComment(line) {
          let inQuotes = false;
          for (let i = 0; i < line.length; i++) {
            if (line[i] === '"') {
              inQuotes = !inQuotes;
            }
            if (line[i] === ";" && !inQuotes) {
              return {
                value: line.substring(0, i).trim(),
                comment: line.substring(i + 1).trim(),
              };
            }
          }
          return { value: line.trim(), comment: null };
        }

        parse(iniString) {
          this.defines = {};
          this.config = {};
          const lines = iniString.split(/\r?\n/);
          const processedLines = this.preprocess(lines);

          let currentPage = null;
          let currentGroup = null;
          let currentMenuDialog = null;
          let currentMenu = null;
          let currentGroupMenu = null;

          for (const line of processedLines) {
            const trimmedLine = line.trim();
            if (
              !trimmedLine ||
              trimmedLine.startsWith(";") ||
              trimmedLine.startsWith("//")
            )
              continue;

            const sectionMatch = trimmedLine.match(/^\[(.+)\]$/);
            if (sectionMatch) {
              this.currentSection = sectionMatch[1];
              currentPage = null;
              currentGroup = null;
              currentMenuDialog = null;
              currentMenu = null;
              currentGroupMenu = null;
              this.currentUserDefinedDialog = null;
              this.currentCurve = null;
              this.currentTable = null;
              this.currentGaugeCategory = "Default";
              this.currentLogger = null;
              this.currentReferenceTable = null;

              const sectionInitializers = {
                ConstantsExtensions: () => ({
                  requiresPowerCycle: [],
                  defaultValue: {},
                  controllerPriority: [],
                }),
                UserDefined: () => ({ dialogs: {} }),
                Menu: () => ({}),
                CurveEditor: () => ({}),
                TableEditor: () => ({}),
                GaugeConfigurations: () => ({}),
                FrontPage: () => ({ gauges: {}, indicators: [] }),
                Constants: () => ({ pages: {} }),
                Datalog: () => ({ entries: [] }),
                LoggerDefinition: () => ({}),
                ReferenceTables: () => ({ tables: {} }),
                Tools: () => ({ tools: [] }),
                VeAnalyze: () => ({ filters: [] }),
                WueAnalyze: () => ({ filters: [] }),
              };

              if (sectionInitializers[this.currentSection]) {
                this.config[this.currentSection] =
                  sectionInitializers[this.currentSection]();
              } else {
                this.config[this.currentSection] =
                  this.config[this.currentSection] || {};
              }
              continue;
            }

            const pageMatch = trimmedLine.match(/^page\s*=\s*(\d+)/i);
            if (pageMatch && this.currentSection === "Constants") {
              currentPage = pageMatch[1];
              this.config.Constants.pages[currentPage] =
                this.config.Constants.pages[currentPage] || {};
              continue;
            }

            const varMatch = trimmedLine.match(/^([\w\.]+)\s*=\s*(.+)$/);
            if (varMatch && this.currentSection) {
              const key = varMatch[1];
              const rawRightHandSide = varMatch[2].trim();

              const { value, comment } =
                this.splitValueAndComment(rawRightHandSide);

              const handlers = {
                ConstantsExtensions: this.handleConstantsExtensions,
                UserDefined: this.handleUserDefinedParsing,
                Menu: this.handleMenuParsing,
                CurveEditor: this.handleCurveEditorParsing,
                TableEditor: this.handleTableEditorParsing,
                GaugeConfigurations: this.handleGaugeConfigurationsParsing,
                FrontPage: this.handleFrontPageParsing,
                Datalog: this.handleDatalogParsing,
                LoggerDefinition: this.handleLoggerDefinitionParsing,
                ReferenceTables: this.handleReferenceTablesParsing,
                Tools: this.handleToolsParsing,
                VeAnalyze: this.handleAnalyzeParsing,
                WueAnalyze: this.handleAnalyzeParsing,
                SettingGroups: this.handleSettingGroups,
              };

              if (handlers[this.currentSection]) {
                handlers[this.currentSection].call(
                  this,
                  key,
                  value,
                  comment,
                  currentGroup
                );
                if (
                  this.currentSection === "SettingGroups" &&
                  key === "settingGroup"
                ) {
                  currentGroup = this.splitRespectingQuotes(value)[0];
                }
              } else {
                const parsedValue = this.parseLine(key, value);
                if (
                  comment &&
                  typeof parsedValue === "object" &&
                  parsedValue !== null &&
                  !Array.isArray(parsedValue)
                ) {
                  parsedValue.comment = comment;
                }

                if (this.currentSection === "Constants" && currentPage) {
                  this.config.Constants.pages[currentPage][key] = parsedValue;
                } else {
                  this.config[this.currentSection][key] = parsedValue;
                }
              }
            }
          }
          return this.config;
        }

        handleFrontPageParsing(key, value, comment) {
          if (key.startsWith("gauge")) {
            this.config.FrontPage.gauges[key] = value;
          } else if (key === "indicator") {
            const parts = this.splitRespectingQuotes(value);
            const indicator = {
              expression: parts[0],
              offLabel: parts[1] ? parts[1].replace(/"/g, "") : "",
              onLabel: parts[2] ? parts[2].replace(/"/g, "") : "",
              offBg: parts[3],
              offFg: parts[4],
              onBg: parts[5],
              onFg: parts[6],
            };
            if (comment) indicator.comment = comment;
            this.config.FrontPage.indicators.push(indicator);
          }
        }

        handleGaugeConfigurationsParsing(key, value, comment) {
          if (key === "gaugeCategory") {
            this.currentGaugeCategory = value.replace(/"/g, "");
            if (!this.config.GaugeConfigurations[this.currentGaugeCategory]) {
              this.config.GaugeConfigurations[this.currentGaugeCategory] = [];
            }
          } else {
            const parts = this.splitRespectingQuotes(value);
            const gauge = {
              name: key,
              variable: parts[0],
              title: parts[1] ? parts[1].replace(/"/g, "") : "",
              units: parts[2] ? parts[2].replace(/"/g, "") : "",
              low: this.parseNumberOrExpr(parts[3]),
              high: this.parseNumberOrExpr(parts[4]),
              lowDanger: this.parseNumberOrExpr(parts[5]),
              lowWarning: this.parseNumberOrExpr(parts[6]),
              highWarning: this.parseNumberOrExpr(parts[7]),
              highDanger: this.parseNumberOrExpr(parts[8]),
              valueDecimals: this.parseNumberOrExpr(parts[9]),
              labelDecimals: this.parseNumberOrExpr(parts[10]),
            };
            if (comment) gauge.comment = comment;
            if (!this.config.GaugeConfigurations[this.currentGaugeCategory]) {
              this.config.GaugeConfigurations[this.currentGaugeCategory] = [];
            }
            this.config.GaugeConfigurations[this.currentGaugeCategory].push(
              gauge
            );
          }
        }

        handleDatalogParsing(key, value, comment) {
          if (key === "entry") {
            const parts = this.splitRespectingQuotes(value);
            const entry = {
              channel: parts[0],
              label: parts[1] ? parts[1].replace(/"/g, "") : "",
              type: parts[2],
              format: parts[3] ? parts[3].replace(/"/g, "") : "",
            };
            if (parts[4]) entry.condition = parts[4];
            if (comment) entry.comment = comment;
            this.config.Datalog.entries.push(entry);
          }
        }

        handleLoggerDefinitionParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          if (key === "loggerDef") {
            const [id, title, type] = parts;
            this.currentLogger = {
              title: title.replace(/"/g, ""),
              type,
              properties: {},
              recordFields: [],
              calcFields: [],
            };
            if (comment) this.currentLogger.comment = comment;
            this.config.LoggerDefinition[id] = this.currentLogger;
          } else if (this.currentLogger) {
            if (key === "recordField") {
              this.currentLogger.recordFields.push({
                name: parts[0],
                header: parts[1].replace(/"/g, ""),
                startBit: parseInt(parts[2]),
                bitCount: parseInt(parts[3]),
                scale: parseFloat(parts[4]),
                units: parts[5].replace(/"/g, ""),
              });
            } else if (key === "calcField") {
              this.currentLogger.calcFields.push({
                name: parts[0],
                header: parts[1].replace(/"/g, ""),
                units: parts[2].replace(/"/g, ""),
                expression: parts[3],
                hidden: parts[4] === "hidden",
              });
            } else {
              const parsedValue = this.parseLine(key, value);
              if (
                comment &&
                typeof parsedValue === "object" &&
                parsedValue !== null
              ) {
                parsedValue.comment = comment;
              }
              this.currentLogger.properties[key] = parsedValue;
            }
          }
        }

        handleReferenceTablesParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          if (key === "referenceTable") {
            const [id, title] = parts;
            this.currentReferenceTable = {
              title: title.replace(/"/g, ""),
              properties: {},
              generators: [],
              solutions: [],
            };
            if (comment) this.currentReferenceTable.comment = comment;
            this.config.ReferenceTables.tables[id] = this.currentReferenceTable;
          } else if (this.currentReferenceTable) {
            if (key === "tableGenerator") {
              this.currentReferenceTable.generators.push({
                type: parts[0],
                label: parts[1].replace(/"/g, ""),
              });
            } else if (key === "thermOption" || key === "solution") {
              this.currentReferenceTable.solutions.push({
                name: parts[0].replace(/"/g, ""),
                value: parts.slice(1).join(", "),
              });
            } else {
              const parsedValue = this.parseLine(key, value);
              if (
                comment &&
                typeof parsedValue === "object" &&
                parsedValue !== null
              ) {
                parsedValue.comment = comment;
              }
              this.currentReferenceTable.properties[key] = parsedValue;
            }
          } else {
            const parsedValue = this.parseLine(key, value);
            if (
              comment &&
              typeof parsedValue === "object" &&
              parsedValue !== null
            ) {
              parsedValue.comment = comment;
            }
            this.config.ReferenceTables[key] = parsedValue;
          }
        }

        handleToolsParsing(key, value, comment) {
          if (key === "addTool") {
            const [name, panel, tableId] = this.splitRespectingQuotes(value);
            const tool = { name, panel: panel.replace(/"/g, ""), tableId };
            if (comment) tool.comment = comment;
            this.config.Tools.tools.push(tool);
          }
        }

        handleAnalyzeParsing(key, value, comment) {
          const section = this.config[this.currentSection];
          if (!section) return;

          const parts = this.splitRespectingQuotes(value);
          if (key.endsWith("AnalyzeMap")) {
            if (key === "veAnalyzeMap") {
              section.map = {
                tableName: parts[0],
                lambdaTargetTableName: parts[1],
                lambdaChannel: parts[2],
                egoCorrectionChannel: parts[3],
              };
            } else if (key === "wueAnalyzeMap") {
              section.map = {
                wueCurveName: parts[0],
                afrTempCompensationCurve: parts[1],
                lambdaTargetTableName: parts[2],
                lambdaChannel: parts[3],
                coolantTempChannel: parts[4],
                wueChannel: parts[5],
                egoCorrectionChannel: parts[6],
              };
            }
            if (comment && section.map) section.map.comment = comment;
          } else if (key === "lambdaTargetTables") {
            section.lambdaTargetTables = parts;
          } else if (key === "filter") {
            const filter = {
              id: parts[0],
              label: parts[1] ? parts[1].replace(/"/g, "") : null,
              channel: parts[2],
              operator: parts[3],
              value: parts[4],
              enabled: parts[5] === "true",
            };
            if (comment) filter.comment = comment;
            section.filters.push(filter);
          }
        }

        handleConstantsExtensions(key, value, comment) {
          if (key === "requiresPowerCycle" || key === "controllerPriority") {
            this.config.ConstantsExtensions[key].push(value);
          } else if (key === "defaultValue") {
            const [defKey, ...defValParts] = this.splitRespectingQuotes(value);
            this.config.ConstantsExtensions.defaultValue[defKey] = defValParts
              .join(", ")
              .replace(/^"|"$/g, "");
          } else {
            const parsedValue = this.parseLine(key, value);
            if (
              comment &&
              typeof parsedValue === "object" &&
              parsedValue !== null
            ) {
              parsedValue.comment = comment;
            }
            this.config.ConstantsExtensions[key] = parsedValue;
          }
        }

        handleSettingGroups(key, value, comment, currentGroup) {
          if (key === "settingGroup") {
            const [name, displayName] = this.splitRespectingQuotes(value);
            this.config.SettingGroups[name] = {
              displayName: displayName.replace(/"/g, ""),
              options: {},
            };
          } else if (key === "settingOption" && currentGroup) {
            const [name, displayName] = this.splitRespectingQuotes(value);
            this.config.SettingGroups[currentGroup].options[name] =
              displayName.replace(/"/g, "");
          }
        }

        handleUserDefinedParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          let element = null;

          switch (key) {
            case "dialog":
              const [dialogId, title, layout] = parts;
              if (!dialogId) break;
              this.currentUserDefinedDialog = {
                title: title ? title.replace(/"/g, "") : "",
                layout: layout || "yAxis",
                content: [],
              };
              if (comment) this.currentUserDefinedDialog.comment = comment;
              this.config.UserDefined.dialogs[dialogId] =
                this.currentUserDefinedDialog;
              this.lastUserDefinedElement = this.currentUserDefinedDialog;
              break;
            case "topicHelp":
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.topicHelp = value.replace(
                  /"/g,
                  ""
                );
              break;
            case "field":
              const [labelOrVar, variable, ...rest] = parts;
              if (!labelOrVar) break;
              if (variable) {
                element = {
                  type: "field",
                  label: labelOrVar.replace(/"/g, ""),
                  variable,
                };
                if (rest[0] && rest[0] !== "{}") {
                  element.condition = rest[0];
                }
                if (rest[1] && rest[1] !== "{}") {
                  element.highlightCondition = rest[1];
                }
              } else {
                element = { type: "label", text: labelOrVar.replace(/"/g, "") };
                if (labelOrVar.startsWith("!")) element.style = "warning";
                if (labelOrVar.startsWith("#")) element.style = "heading";
              }
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "panel":
              const [panelDialogId, panelLayout] = parts;
              element = {
                type: "panel",
                dialogId: panelDialogId,
                layout: panelLayout,
              };
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "commandButton":
              if (!parts[0]) break;
              element = {
                type: "button",
                label: parts[0].replace(/"/g, ""),
                command: parts[1],
              };
              if (parts[2]) element.condition = parts[2];
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "slider":
              if (!parts[0]) break;
              element = {
                type: "slider",
                label: parts[0].replace(/"/g, ""),
                variable: parts[1],
                orientation: parts[2],
              };
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "settingSelector":
              element = {
                type: "selector",
                label: value.replace(/"/g, ""),
                options: [],
              };
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "settingOption":
              if (
                this.lastUserDefinedElement &&
                this.lastUserDefinedElement.type === "selector"
              ) {
                const [optLabel, ...optSettings] = parts;
                if (!optLabel) break;
                const settings = {};
                optSettings.forEach((s) => {
                  const [sKey, sVal] = s.split("=");
                  settings[sKey] = isNaN(sVal) ? sVal : parseFloat(sVal);
                });
                this.lastUserDefinedElement.options.push({
                  label: optLabel.replace(/"/g, ""),
                  settings,
                });
              }
              break;
            case "liveGraph":
              const [graphId, graphTitle] = parts;
              element = {
                type: "liveGraph",
                id: graphId,
                title: graphTitle.replace(/"/g, ""),
                lines: [],
              };
              if (comment) element.comment = comment;
              if (this.currentUserDefinedDialog)
                this.currentUserDefinedDialog.content.push(element);
              this.lastUserDefinedElement = element;
              break;
            case "graphLine":
              if (
                this.lastUserDefinedElement &&
                this.lastUserDefinedElement.type === "liveGraph"
              ) {
                const line = {
                  variable: parts[0],
                  units: parts[1] ? parts[1].replace(/"/g, "") : null,
                  low: parts[2] ? parseFloat(parts[2]) : null,
                  high: parts[3] ? parseFloat(parts[3]) : null,
                  lowColor: parts[4] || null,
                  highColor: parts[5] || null,
                };
                if (comment) line.comment = comment;
                this.lastUserDefinedElement.lines.push(line);
              }
              break;
          }
        }

        handleCurveEditorParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          switch (key) {
            case "curve":
              const [id, title] = parts;
              this.currentCurve = {
                title: title ? title.replace(/"/g, "") : "",
                properties: {},
              };
              if (comment) this.currentCurve.comment = comment;
              this.config.CurveEditor[id] = this.currentCurve;
              break;
            case "columnLabel":
            case "lineLabel":
              if (this.currentCurve) {
                this.currentCurve.properties[key] = parts.map((p) =>
                  p.replace(/"/g, "")
                );
              }
              break;
            case "xAxis":
            case "yAxis":
              if (this.currentCurve) {
                const [low, high, digits] = parts.map((p) => parseFloat(p));
                this.currentCurve.properties[key] = { low, high, digits };
              }
              break;
            case "xBins":
            case "yBins":
              if (this.currentCurve) {
                const [variable, channel] = parts;
                this.currentCurve.properties[key] = { variable, channel };
              }
              break;
            case "gauge":
            case "size":
              if (this.currentCurve) {
                this.currentCurve.properties[key] = value;
              }
              break;
          }
        }

        handleTableEditorParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          switch (key) {
            case "table":
              const [tableId, map3dId, title, page] = parts;
              this.currentTable = {
                map3dId: map3dId,
                title: title.replace(/"/g, ""),
                page: parseInt(page),
                properties: {},
              };
              if (comment) this.currentTable.comment = comment;
              this.config.TableEditor[tableId] = this.currentTable;
              break;
            case "topicHelp":
              if (this.currentTable)
                this.currentTable.topicHelp = value.replace(/"/g, "");
              break;
            case "xBins":
            case "yBins":
            case "zBins":
              if (this.currentTable) {
                const [variable, channel] = parts;
                this.currentTable.properties[key] = { variable, channel };
              }
              break;
            case "xyLabels":
            case "upDownLabel":
              if (this.currentTable) {
                this.currentTable.properties[key] = parts.map((p) =>
                  p.replace(/"/g, "")
                );
              }
              break;
            case "gridHeight":
              if (this.currentTable) {
                this.currentTable.properties[key] = parseFloat(parts[0]);
              }
              break;
            case "gridOrient":
              if (this.currentTable) {
                this.currentTable.properties[key] = parts.map((p) =>
                  parseFloat(p)
                );
              }
              break;
          }
        }

        handleMenuParsing(key, value, comment) {
          const parts = this.splitRespectingQuotes(value);
          switch (key) {
            case "menuDialog":
              this.currentMenuDialog = value;
              this.config.Menu[this.currentMenuDialog] =
                this.config.Menu[this.currentMenuDialog] || [];
              this.currentMenu = null;
              this.currentGroupMenu = null;
              break;
            case "menu":
              if (!this.currentMenuDialog) break;
              this.currentMenu = {
                type: "menu",
                label: value.replace(/"/g, ""),
                items: [],
              };
              if (comment) this.currentMenu.comment = comment;
              this.config.Menu[this.currentMenuDialog].push(this.currentMenu);
              this.currentGroupMenu = null;
              break;
            case "subMenu":
              if (!this.currentMenu) break;
              if (parts[0] === "std_separator") {
                this.currentMenu.items.push({ type: "separator" });
              } else {
                const item = {
                  type: "item",
                  id: parts[0],
                  label: parts[1].replace(/"/g, ""),
                };
                if (parts[2])
                  item.value = isNaN(parts[2])
                    ? parts[2]
                    : parseInt(parts[2], 10);
                if (parts[3]) item.condition = parts[3];
                if (comment) item.comment = comment;
                this.currentMenu.items.push(item);
              }
              break;
            case "groupMenu":
              if (!this.currentMenu) break;
              this.currentGroupMenu = {
                type: "group",
                label: value.replace(/"/g, ""),
                items: [],
              };
              if (comment) this.currentGroupMenu.comment = comment;
              this.currentMenu.items.push(this.currentGroupMenu);
              break;
            case "groupChildMenu":
              if (!this.currentGroupMenu) break;
              const childItem = {
                type: "item",
                id: parts[0],
                label: parts[1].replace(/"/g, ""),
              };
              if (parts[2])
                childItem.value = isNaN(parts[2])
                  ? parts[2]
                  : parseInt(parts[2], 10);
              if (parts[3]) childItem.condition = parts[3];
              if (comment) childItem.comment = comment;
              this.currentGroupMenu.items.push(childItem);
              break;
          }
        }

        preprocess(lines) {
          const defines = {};
          for (const line of lines) {
            const trimmedLine = line.trim();
            const defineMatch = trimmedLine.match(
              /^#define\s+([\w$]+)\s*=\s*(.+)$/
            );
            if (defineMatch) {
              defines[defineMatch[1]] = defineMatch[2].trim();
            }
          }

          let substitutionsMade = true;
          let iterations = 0;
          while (substitutionsMade && iterations < 15) {
            substitutionsMade = false;
            for (const key in defines) {
              if (defines[key].includes("$")) {
                for (const subKey in defines) {
                  if (key !== subKey) {
                    const regex = new RegExp(`\\$${subKey}`, "g");
                    const newValue = defines[key].replace(
                      regex,
                      defines[subKey]
                    );
                    if (newValue !== defines[key]) {
                      defines[key] = newValue;
                      substitutionsMade = true;
                    }
                  }
                }
              }
            }
            iterations++;
          }
          this.defines = defines;

          let processed = [];
          const ifStack = [];

          for (const line of lines) {
            let trimmedLine = line.trim();

            if (trimmedLine.startsWith("#if")) {
              const condition = trimmedLine.substring(4).trim();
              ifStack.push(this.flags[condition] || false);
              continue;
            }

            if (trimmedLine.startsWith("#else")) {
              if (ifStack.length > 0) {
                ifStack[ifStack.length - 1] = !ifStack[ifStack.length - 1];
              }
              continue;
            }

            if (trimmedLine.startsWith("#endif")) {
              ifStack.pop();
              continue;
            }

            if (ifStack.some((v) => !v)) {
              continue;
            }

            if (
              trimmedLine.startsWith("#define") ||
              trimmedLine.startsWith("#unset")
            ) {
              continue;
            }

            for (const defKey in this.defines) {
              trimmedLine = trimmedLine.replace(
                new RegExp(`\\$${defKey}`, "g"),
                this.defines[defKey]
              );
            }

            processed.push(trimmedLine);
          }

          return processed;
        }

        parseLine(key, valueString) {
          const parts = this.splitRespectingQuotes(valueString);
          const type = parts[0];

          try {
            switch (type) {
              case "scalar":
                return this.parseScalar(parts);
              case "array":
                return this.parseArray(parts);
              case "bits":
                return this.parseBits(parts);
              case "string":
                return {
                  type: "string",
                  class: parts[1],
                  length: parseInt(parts[2]),
                };
              default:
                if (parts.length === 1) {
                  return parts[0].replace(/^"|"$/g, "");
                }
                return parts.map((s) => s.trim().replace(/"/g, ""));
            }
          } catch (e) {
            console.warn(`Could not parse line: ${key} = ${valueString}`, e);
            return valueString;
          }
        }

        parseScalar(parts) {
          const obj = {
            type: "scalar",
            class: parts[1],
            offset: parseInt(parts[2]),
          };
          let currentIndex = 3;
          obj.units = parts[currentIndex++].replace(/"/g, "");
          obj.scale = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.translate = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.low = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.high = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.digits = this.parseNumberOrExpr(parts[currentIndex++]);
          return obj;
        }

        parseArray(parts) {
          const obj = {
            type: "array",
            class: parts[1],
            offset: parseInt(parts[2]),
          };
          let currentIndex = 3;

          const shapeMatch = parts[currentIndex++]
            .trim()
            .match(/\[\s*(\d+)(?:\s*x\s*(\d+))?\s*\]/);
          if (shapeMatch) {
            const dim1 = parseInt(shapeMatch[1]);
            const dim2 = shapeMatch[2] ? parseInt(shapeMatch[2]) : null;

            if (dim2 !== null) {
              obj.shape = { rows: dim1, columns: dim2 };
            } else {
              obj.shape = { length: dim1 };
            }
          } else {
            obj.shape = null;
          }

          obj.units = parts[currentIndex++].replace(/"/g, "");
          obj.scale = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.translate = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.low = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.high = this.parseNumberOrExpr(parts[currentIndex++]);
          obj.digits = this.parseNumberOrExpr(parts[currentIndex++]);
          return obj;
        }

        parseBits(parts) {
          const obj = { type: "bits", class: parts[1] };
          let currentIndex = 2;
          if (!parts[currentIndex].startsWith("[")) {
            obj.offset = parseInt(parts[currentIndex++]);
          }
          const bitMatch = parts[currentIndex++].match(/\[(\d+):(\d+)\]/);
          if (bitMatch) {
            obj.startBit = parseInt(bitMatch[1]);
            obj.endBit = parseInt(bitMatch[2]);
          }
          obj.options = parts
            .slice(currentIndex)
            .map((opt) => opt.replace(/"/g, ""));
          return obj;
        }

        parseNumberOrExpr(part) {
          if (part === undefined) return null;
          if (part.startsWith("{") && part.endsWith("}")) {
            return part; // Store expression as string
          }
          return parseFloat(part);
        }
      }

      // ===================================================================================
      // DOM Interaction
      // ===================================================================================
      document.addEventListener("DOMContentLoaded", () => {
        const iniInput = document.getElementById("iniInput");
        const parseButton = document.getElementById("parseButton");
        const jsonOutput = document.getElementById("jsonOutput");
        const spinner = document.getElementById("spinner");
        const copyButton = document.getElementById("copyButton");
        const fileInput = document.getElementById("fileInput");

        let parsedJsonString = "";
        let parseTimeout = null;
        let parsedConfig = null;
        let filesProcessed = 0;

        // Debounced parse function
        function debouncedParse() {
          if (parseTimeout) {
            clearTimeout(parseTimeout);
          }
          parseTimeout = setTimeout(() => {
            parseButton.click();
          }, 1000); // Wait 1 second after user stops typing
        }

        // Character count functionality
        function updateCharCount() {
          const charCount = document.getElementById("char-count");
          const length = iniInput.value.length;
          charCount.textContent = `${length.toLocaleString()} characters`;

          if (length > 100000) {
            charCount.style.color = "#ef4444";
          } else if (length > 50000) {
            charCount.style.color = "#f59e0b";
          } else {
            charCount.style.color = "#6b7280";
          }
        }

        // Update stats
        function updateStats(config) {
          document.getElementById("files-processed").textContent =
            ++filesProcessed;

          let totalKeys = 0;
          const countKeys = (obj) => {
            if (typeof obj === "object" && obj !== null) {
              totalKeys += Object.keys(obj).length;
              Object.values(obj).forEach(countKeys);
            }
          };
          countKeys(config);
          document.getElementById("total-keys").textContent =
            totalKeys.toLocaleString();
        }

        // Search functionality with improved contrast and navigation
        function setupSearch() {
          const searchInput = document.getElementById("searchInput");
          const jsonOutput = document.getElementById("jsonOutput");
          let currentSearchResults = [];
          let currentSearchIndex = -1;

          // Create search navigation buttons
          const searchNav = document.createElement("div");
          searchNav.className = "search-navigation hidden";
          searchNav.innerHTML = `
            <div class="flex items-center gap-2 text-xs text-white/70">
              <button id="prevResult" class="btn-secondary text-xs px-2 py-1">‚Üë</button>
              <span id="searchCounter">0 / 0</span>
              <button id="nextResult" class="btn-secondary text-xs px-2 py-1">‚Üì</button>
            </div>
          `;
          searchInput.parentElement.appendChild(searchNav);

          const prevBtn = searchNav.querySelector("#prevResult");
          const nextBtn = searchNav.querySelector("#nextResult");
          const counter = searchNav.querySelector("#searchCounter");

          function clearSearch() {
            // Remove all highlights
            jsonOutput
              .querySelectorAll(".search-highlight, .search-current")
              .forEach((el) => {
                el.classList.remove("search-highlight", "search-current");
              });
            currentSearchResults = [];
            currentSearchIndex = -1;
            searchNav.classList.add("hidden");
          }

          function highlightText(element, query) {
            const text = element.textContent;
            const lowerText = text.toLowerCase();
            const lowerQuery = query.toLowerCase();

            if (!lowerText.includes(lowerQuery)) return;

            let highlightedHTML = "";
            let lastIndex = 0;
            let index = lowerText.indexOf(lowerQuery);

            while (index !== -1) {
              // Add text before match
              highlightedHTML += text.substring(lastIndex, index);
              // Add highlighted match
              highlightedHTML += `<mark class="search-highlight">${text.substring(
                index,
                index + query.length
              )}</mark>`;

              lastIndex = index + query.length;
              index = lowerText.indexOf(lowerQuery, lastIndex);
            }

            // Add remaining text
            highlightedHTML += text.substring(lastIndex);
            element.innerHTML = highlightedHTML;

            // Store reference to highlighted elements
            element
              .querySelectorAll(".search-highlight")
              .forEach((highlight) => {
                currentSearchResults.push({
                  element: highlight,
                  node: element.closest(".json-node"),
                });
              });
          }

          function navigateToResult(index) {
            if (currentSearchResults.length === 0) return;

            // Remove current highlight
            currentSearchResults.forEach((result) => {
              result.element.classList.remove("search-current");
            });

            // Update index
            currentSearchIndex = index;
            if (currentSearchIndex >= currentSearchResults.length)
              currentSearchIndex = 0;
            if (currentSearchIndex < 0)
              currentSearchIndex = currentSearchResults.length - 1;

            // Highlight current result
            const currentResult = currentSearchResults[currentSearchIndex];
            currentResult.element.classList.add("search-current");

            // Expand parent nodes if collapsed
            let parent = currentResult.node;
            while (parent) {
              const children = parent.querySelector(".json-children");
              const toggle = parent.querySelector(".json-toggle");

              if (children && !children.classList.contains("expanded")) {
                children.classList.add("expanded");
                toggle.classList.remove("collapsed");
                toggle.classList.add("expanded");
              }

              parent = parent.parentElement?.closest(".json-node");
            }

            // Scroll to result with smooth behavior
            currentResult.element.scrollIntoView({
              behavior: "smooth",
              block: "center",
              inline: "nearest",
            });

            // Update counter
            counter.textContent = `${currentSearchIndex + 1} / ${
              currentSearchResults.length
            }`;
          }

          // Search input handler
          searchInput.addEventListener("input", (e) => {
            const query = e.target.value.trim();

            clearSearch();

            if (query === "") {
              // Restore original text content
              jsonOutput
                .querySelectorAll(".json-key, .json-value")
                .forEach((node) => {
                  if (node.querySelector("mark")) {
                    node.textContent = node.textContent; // This removes HTML tags
                  }
                });
              return;
            }

            // Search and highlight
            const nodes = jsonOutput.querySelectorAll(".json-key, .json-value");
            nodes.forEach((node) => {
              // First restore original text if it was previously highlighted
              if (node.querySelector("mark")) {
                node.textContent = node.textContent;
              }

              const text = node.textContent.toLowerCase();
              if (text.includes(query.toLowerCase())) {
                highlightText(node, query);
              }
            });

            if (currentSearchResults.length > 0) {
              searchNav.classList.remove("hidden");
              navigateToResult(0);
            }
          });

          // Navigation handlers
          prevBtn.addEventListener("click", () => {
            navigateToResult(currentSearchIndex - 1);
          });

          nextBtn.addEventListener("click", () => {
            navigateToResult(currentSearchIndex + 1);
          });

          // Keyboard navigation
          searchInput.addEventListener("keydown", (e) => {
            if (currentSearchResults.length === 0) return;

            if (e.key === "Enter") {
              e.preventDefault();
              navigateToResult(
                e.shiftKey ? currentSearchIndex - 1 : currentSearchIndex + 1
              );
            } else if (e.key === "Escape") {
              searchInput.value = "";
              clearSearch();
              jsonOutput
                .querySelectorAll(".json-key, .json-value")
                .forEach((node) => {
                  if (node.querySelector("mark")) {
                    node.textContent = node.textContent;
                  }
                });
            }
          });
        }

        // Download functionality
        function downloadJSON() {
          if (!parsedJsonString) return;

          const blob = new Blob([parsedJsonString], {
            type: "application/json",
          });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `speeduino-config-${new Date()
            .toISOString()
            .slice(0, 10)}.json`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          showNotification("JSON file downloaded!", "success");
        }

        // Notification system
        function showNotification(message, type = "info") {
          const notification = document.createElement("div");
          notification.className = `fixed top-4 left-1/2 transform -translate-x-1/2 z-50 px-6 py-3 rounded-lg font-medium text-white transition-all duration-300 ${
            type === "success"
              ? "bg-green-500"
              : type === "error"
              ? "bg-red-500"
              : "bg-blue-500"
          }`;
          notification.textContent = message;
          notification.style.transform = "translate(-50%, -100px)";

          document.body.appendChild(notification);

          setTimeout(() => {
            notification.style.transform = "translate(-50%, 0)";
          }, 100);

          setTimeout(() => {
            notification.style.transform = "translate(-50%, -100px)";
            setTimeout(() => {
              if (notification.parentNode) {
                notification.parentNode.removeChild(notification);
              }
            }, 300);
          }, 3000);
        }

        // Keyboard shortcuts
        function setupKeyboardShortcuts() {
          document.addEventListener("keydown", (e) => {
            if (e.ctrlKey || e.metaKey) {
              switch (e.key) {
                case "f":
                  e.preventDefault();
                  document.getElementById("searchInput").focus();
                  break;
                case "e":
                  e.preventDefault();
                  if (!document.getElementById("expandButton").disabled) {
                    document.getElementById("expandButton").click();
                  }
                  break;
                case "r":
                  e.preventDefault();
                  if (!document.getElementById("collapseButton").disabled) {
                    document.getElementById("collapseButton").click();
                  }
                  break;
              }
            }
          });
        }

        // Drag and drop functionality
        function setupDragDrop() {
          const dragDropArea = document.getElementById("dragDropArea");
          const fileInput = document.getElementById("fileInput");

          dragDropArea.addEventListener("click", () => {
            fileInput.click();
          });

          dragDropArea.addEventListener("dragover", (e) => {
            e.preventDefault();
            dragDropArea.classList.add("drag-over");
          });

          dragDropArea.addEventListener("dragleave", (e) => {
            e.preventDefault();
            if (!dragDropArea.contains(e.relatedTarget)) {
              dragDropArea.classList.remove("drag-over");
            }
          });

          dragDropArea.addEventListener("drop", (e) => {
            e.preventDefault();
            dragDropArea.classList.remove("drag-over");

            const files = e.dataTransfer.files;
            if (files.length > 0) {
              handleFiles(files);
            }
          });
        }

        // Handle multiple files
        function handleFiles(files) {
          Array.from(files).forEach((file, index) => {
            if (
              file.type === "text/plain" ||
              file.name.endsWith(".ini") ||
              file.name.endsWith(".txt")
            ) {
              const reader = new FileReader();
              reader.onload = (e) => {
                if (index === 0) {
                  iniInput.value = e.target.result;
                } else {
                  iniInput.value += "\n\n" + e.target.result;
                }
                updateCharCount();

                if (index === files.length - 1) {
                  setTimeout(() => parseButton.click(), 100);
                }
              };
              reader.readAsText(file);
            } else {
              showNotification(
                `File "${file.name}" is not a valid .ini file`,
                "error"
              );
            }
          });
        }

        // Initialize with welcome message
        jsonOutput.innerHTML =
          '<div class="text-center text-white/60 py-8"><span class="text-4xl mb-4 block">üåü</span><h3 class="text-lg font-semibold mb-2">Welcome to Speeduino INI Parser</h3><p>Upload a .ini file, paste content, or load a sample to get started!</p></div>';

        parseButton.addEventListener("click", () => {
          const iniContent = iniInput.value;
          if (!iniContent) {
            jsonOutput.innerHTML =
              '<div class="text-center text-white/60 py-8"><span class="text-4xl mb-4 block">üìÑ</span><p>Please paste your .ini content or drag & drop a file to get started.</p></div>';
            return;
          }

          const startTime = performance.now();

          // Update UI state
          jsonOutput.innerHTML = "";
          spinner.classList.remove("hidden");
          copyButton.disabled = true;
          document.getElementById("expandButton").disabled = true;
          document.getElementById("collapseButton").disabled = true;
          document.getElementById("downloadButton").disabled = true;
          document.getElementById("searchInput").disabled = true;

          // Update status
          document.getElementById("input-status").style.display = "flex";
          document.getElementById("input-status").textContent = "Processing...";
          document.getElementById("input-status").className =
            "status-indicator status-processing";

          parsedJsonString = ""; // Reset on new parse

          setTimeout(() => {
            try {
              const parser = new SpeeduinoIniParser();
              const config = parser.parse(iniContent);
              parsedConfig = config;
              parsedJsonString = JSON.stringify(config, null, 2);

              const endTime = performance.now();
              const parseTime = Math.round(endTime - startTime);
              document.getElementById(
                "parse-time"
              ).textContent = `${parseTime}ms`;

              // Update stats
              updateStats(config);

              // Enable controls
              copyButton.disabled = false;
              document.getElementById("expandButton").disabled = false;
              document.getElementById("collapseButton").disabled = false;
              document.getElementById("downloadButton").disabled = false;
              document.getElementById("searchInput").disabled = false;

              // Update status
              document.getElementById("input-status").textContent = "Completed";
              document.getElementById("input-status").className =
                "status-indicator status-success";
              document.getElementById("output-status").style.display = "flex";

              // Render the JSON Tree with batching
              jsonOutput.innerHTML = ""; // Clear previous content
              renderJsonTreeAsync(config, jsonOutput).then(() => {
                spinner.classList.add("hidden");
                setupSearch();
                updateNodeCount();
                showNotification(
                  "Configuration parsed successfully!",
                  "success"
                );
              });
            } catch (error) {
              jsonOutput.innerHTML = `<div class="text-center text-red-400 py-8">
                <span class="text-4xl mb-4 block">‚ùå</span>
                <h3 class="text-lg font-semibold mb-2">Parsing Error</h3>
                <p class="text-sm">${error.message}</p>
                <details class="mt-4 text-xs text-left">
                  <summary class="cursor-pointer">Show Details</summary>
                  <pre class="mt-2 p-2 bg-black/20 rounded">${error.stack}</pre>
                </details>
              </div>`;

              // Update status
              document.getElementById("input-status").textContent = "Error";
              document.getElementById("input-status").className =
                "status-indicator status-error";

              console.error("Parsing Error:", error);
              spinner.classList.add("hidden");
              showNotification("Failed to parse configuration", "error");
            }
          }, 50);
        });

        // Initialize all features
        setupDragDrop();
        setupKeyboardShortcuts();

        // Set mobile-friendly placeholder
        function updateSearchPlaceholder() {
          const searchInput = document.getElementById("searchInput");
          if (window.innerWidth < 768) {
            searchInput.placeholder =
              "Search JSON... (Enter: next, Esc: clear)";
          } else {
            searchInput.placeholder =
              "Search in JSON tree... (Enter: next, Shift+Enter: prev, Esc: clear)";
          }
        }

        updateSearchPlaceholder();
        window.addEventListener("resize", updateSearchPlaceholder);

        // Set mobile-friendly footer shortcuts
        function updateFooterShortcuts() {
          const footerShortcuts = document.querySelector(
            ".mt-4.flex.justify-between span"
          );
          if (window.innerWidth < 768) {
            footerShortcuts.innerHTML =
              "Ctrl+F: Search | Ctrl+E: Expand | Ctrl+R: Collapse";
          } else {
            footerShortcuts.innerHTML =
              "Shortcuts: Ctrl+F (Search), Ctrl+E (Expand), Ctrl+R (Collapse) | In Search: Enter (Next), Shift+Enter (Prev), Esc (Clear)";
          }
        }

        updateFooterShortcuts();
        window.addEventListener("resize", updateFooterShortcuts);

        // Update character count on input change (no auto-parsing for manual input)
        iniInput.addEventListener("input", () => {
          updateCharCount();
        });

        // Initial character count
        updateCharCount();

        // File input handler
        fileInput.addEventListener("change", (event) => {
          const files = event.target.files;
          if (files.length > 0) {
            handleFiles(files);
          }
        });

        // Download button
        document
          .getElementById("downloadButton")
          .addEventListener("click", downloadJSON);

        // Clear button
        document.getElementById("clearButton").addEventListener("click", () => {
          iniInput.value = "";
          updateCharCount();
          jsonOutput.innerHTML =
            '<div class="text-center text-white/60 py-8"><span class="text-4xl mb-4 block">üìÑ</span><p>Content cleared. Ready for new input.</p></div>';

          // Reset UI state
          document.getElementById("input-status").style.display = "none";
          document.getElementById("output-status").style.display = "none";
          document.getElementById("searchInput").value = "";
          document.getElementById("searchInput").disabled = true;

          // Reset stats
          document.getElementById("total-keys").textContent = "0";
          document.getElementById("parse-time").textContent = "0ms";
          document.getElementById("node-count").textContent = "0 nodes";

          showNotification("Content cleared", "info");
        });

        // Update node count function
        function updateNodeCount() {
          setTimeout(() => {
            const nodes = document.querySelectorAll(".json-node");
            document.getElementById(
              "node-count"
            ).textContent = `${nodes.length} nodes`;
          }, 100);
        }

        copyButton.addEventListener("click", () => {
          if (!parsedJsonString) return;

          navigator.clipboard
            .writeText(parsedJsonString)
            .then(() => {
              showCopySuccess(copyButton, "Disalin!");
            })
            .catch((err) => {
              console.warn("Async clipboard API failed, trying fallback:", err);
              try {
                const textArea = document.createElement("textarea");
                textArea.value = parsedJsonString;
                textArea.style.position = "fixed";
                textArea.style.top = "-9999px";
                textArea.style.left = "-9999px";
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                document.execCommand("copy");
                document.body.removeChild(textArea);
                showCopySuccess(copyButton, "Disalin!");
              } catch (fallbackErr) {
                console.error("Fallback copy method failed:", fallbackErr);
                copyButton.textContent = "Gagal Menyalin!";
                copyButton.classList.add("bg-red-600");
                setTimeout(() => {
                  copyButton.textContent = "Copy JSON";
                  copyButton.classList.remove("bg-red-600");
                }, 2000);
              }
            });
        });

        document
          .getElementById("expandButton")
          .addEventListener("click", () => {
            jsonOutput
              .querySelectorAll(".json-children")
              .forEach((children) => {
                children.classList.add("expanded");
              });
            jsonOutput.querySelectorAll(".json-toggle").forEach((toggle) => {
              if (!toggle.classList.contains("leaf")) {
                toggle.classList.remove("collapsed");
                toggle.classList.add("expanded");
              }
            });
          });

        document
          .getElementById("collapseButton")
          .addEventListener("click", () => {
            jsonOutput
              .querySelectorAll(".json-children")
              .forEach((children) => {
                children.classList.remove("expanded");
              });
            jsonOutput.querySelectorAll(".json-toggle").forEach((toggle) => {
              if (!toggle.classList.contains("leaf")) {
                toggle.classList.remove("expanded");
                toggle.classList.add("collapsed");
              }
            });
          });

        function showCopySuccess(button, message) {
          const originalText = button.textContent;
          const originalClasses = [...button.classList];
          button.textContent = message;
          button.classList.remove(
            "bg-gray-200",
            "hover:bg-gray-300",
            "bg-blue-100",
            "hover:bg-blue-200"
          );
          button.classList.add(
            "bg-green-500",
            "hover:bg-green-600",
            "text-white"
          );
          setTimeout(() => {
            button.textContent = originalText;
            button.className = originalClasses.join(" ");
          }, 2000);
        }

        async function renderJsonTreeAsync(data, container) {
          const progressText = document.getElementById("progress-text");
          const progressBar = document.getElementById("progress-bar");
          const progressFill = document.getElementById("progress-fill");

          progressText.textContent = "Rendering JSON tree...";
          progressBar.classList.remove("hidden");

          const viewerContainer = document.createElement("div");
          viewerContainer.className = "json-viewer";
          container.appendChild(viewerContainer);

          if (typeof data === "object" && data !== null) {
            const isArray = Array.isArray(data);
            if (isArray) {
              await renderItemsBatchWithProgress(
                data,
                viewerContainer,
                0,
                true,
                progressText,
                progressFill
              );
            } else {
              const keys = Object.keys(data);
              await renderObjectBatchWithProgress(
                data,
                keys,
                viewerContainer,
                0,
                false,
                progressText,
                progressFill
              );
            }
          } else {
            viewerContainer.appendChild(createNode(null, data, 0, false, true));
          }

          progressBar.classList.add("hidden");
          progressFill.style.width = "0%";
        }

        async function renderItemsBatchWithProgress(
          items,
          container,
          level,
          isArrayItem,
          progressText,
          progressFill
        ) {
          const BATCH_SIZE = 25; // Render 25 items at a time for better responsiveness
          const total = items.length;

          for (let i = 0; i < total; i += BATCH_SIZE) {
            const batch = items.slice(i, Math.min(i + BATCH_SIZE, total));
            const fragment = document.createDocumentFragment();

            batch.forEach((item, batchIndex) => {
              const actualIndex = i + batchIndex;
              const isLast = actualIndex === total - 1;
              const key = isArrayItem
                ? `[${actualIndex}]`
                : actualIndex.toString();
              fragment.appendChild(
                createNode(key, item, level, isArrayItem, isLast)
              );
            });

            container.appendChild(fragment);

            // Update progress
            const progress = Math.min(100, ((i + BATCH_SIZE) / total) * 100);
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `Rendering... ${Math.floor(progress)}%`;

            // Yield to browser to prevent blocking
            if (i + BATCH_SIZE < total) {
              await new Promise((resolve) => setTimeout(resolve, 0));
            }
          }
        }

        async function renderObjectBatchWithProgress(
          data,
          keys,
          container,
          level,
          isArrayItem,
          progressText,
          progressFill
        ) {
          const BATCH_SIZE = 25; // Render 25 keys at a time for better responsiveness
          const total = keys.length;

          for (let i = 0; i < total; i += BATCH_SIZE) {
            const batch = keys.slice(i, Math.min(i + BATCH_SIZE, total));
            const fragment = document.createDocumentFragment();

            batch.forEach((key, batchIndex) => {
              const actualIndex = i + batchIndex;
              const isLast = actualIndex === total - 1;
              fragment.appendChild(
                createNode(key, data[key], level, isArrayItem, isLast)
              );
            });

            container.appendChild(fragment);

            // Update progress
            const progress = Math.min(100, ((i + BATCH_SIZE) / total) * 100);
            progressFill.style.width = `${progress}%`;
            progressText.textContent = `Rendering... ${Math.floor(progress)}%`;

            // Yield to browser to prevent blocking
            if (i + BATCH_SIZE < total) {
              await new Promise((resolve) => setTimeout(resolve, 0));
            }
          }
        }

        async function renderItemsBatch(items, container, level, isArrayItem) {
          const BATCH_SIZE = 50; // Render 50 items at a time
          const total = items.length;

          for (let i = 0; i < total; i += BATCH_SIZE) {
            const batch = items.slice(i, Math.min(i + BATCH_SIZE, total));
            const fragment = document.createDocumentFragment();

            batch.forEach((item, batchIndex) => {
              const actualIndex = i + batchIndex;
              const isLast = actualIndex === total - 1;
              const key = isArrayItem
                ? `[${actualIndex}]`
                : actualIndex.toString();
              fragment.appendChild(
                createNode(key, item, level, isArrayItem, isLast)
              );
            });

            container.appendChild(fragment);

            // Yield to browser to prevent blocking
            if (i + BATCH_SIZE < total) {
              await new Promise((resolve) => setTimeout(resolve, 0));
            }
          }
        }

        async function renderObjectBatch(
          data,
          keys,
          container,
          level,
          isArrayItem
        ) {
          const BATCH_SIZE = 50; // Render 50 keys at a time
          const total = keys.length;

          for (let i = 0; i < total; i += BATCH_SIZE) {
            const batch = keys.slice(i, Math.min(i + BATCH_SIZE, total));
            const fragment = document.createDocumentFragment();

            batch.forEach((key, batchIndex) => {
              const actualIndex = i + batchIndex;
              const isLast = actualIndex === total - 1;
              fragment.appendChild(
                createNode(key, data[key], level, isArrayItem, isLast)
              );
            });

            container.appendChild(fragment);

            // Yield to browser to prevent blocking
            if (i + BATCH_SIZE < total) {
              await new Promise((resolve) => setTimeout(resolve, 0));
            }
          }
        }

        function createJsonTree(data) {
          const container = document.createElement("div");
          container.className = "json-viewer";

          if (typeof data === "object" && data !== null) {
            const isArray = Array.isArray(data);
            if (isArray) {
              data.forEach((item, index) => {
                const isLast = index === data.length - 1;
                container.appendChild(
                  createNode(`[${index}]`, item, 0, true, isLast)
                );
              });
            } else {
              const keys = Object.keys(data);
              keys.forEach((key, index) => {
                const isLast = index === keys.length - 1;
                container.appendChild(
                  createNode(key, data[key], 0, false, isLast)
                );
              });
            }
          } else {
            container.appendChild(createNode(null, data, 0, false, true));
          }
          return container;
        }

        function createNode(key, value, level, isArrayItem, isLast) {
          const nodeElement = document.createElement("div");
          nodeElement.className = "json-node";

          const contentElement = document.createElement("div");
          contentElement.className = "json-node-content";

          const isObject = typeof value === "object" && value !== null;
          const isArray = Array.isArray(value);

          // Toggle element
          const toggle = document.createElement("span");
          toggle.className = "json-toggle";

          if (isObject) {
            const count = isArray ? value.length : Object.keys(value).length;
            toggle.className += " collapsed";

            const keyElement = document.createElement("span");
            if (isArrayItem) {
              keyElement.className = "json-array-index";
              keyElement.textContent = key;
            } else if (key) {
              keyElement.className = "json-key";
              keyElement.textContent = `"${key}"`;
            }

            const separator = document.createElement("span");
            separator.className = "json-separator";
            separator.textContent = ":";

            const typeIndicator = document.createElement("span");
            typeIndicator.className = "json-bracket";

            const countElement = document.createElement("span");
            countElement.className = "json-count";

            if (isArray) {
              typeIndicator.textContent = "array";
              countElement.textContent = `[${count}]`;
            } else {
              typeIndicator.textContent = "object";
              countElement.textContent = `{${count}}`;
            }

            contentElement.appendChild(toggle);
            if (key) {
              contentElement.appendChild(keyElement);
              contentElement.appendChild(separator);
              contentElement.appendChild(document.createTextNode(" "));
            }
            contentElement.appendChild(typeIndicator);
            contentElement.appendChild(document.createTextNode(" "));
            contentElement.appendChild(countElement);

            if (!isLast) {
              const comma = document.createElement("span");
              comma.className = "json-separator";
              comma.textContent = ",";
              contentElement.appendChild(comma);
            }

            // Children container
            const childrenElement = document.createElement("div");
            childrenElement.className = "json-children";
            let childrenRendered = false;

            nodeElement.appendChild(contentElement);
            nodeElement.appendChild(childrenElement);

            // Lazy render children function
            const renderChildren = () => {
              if (childrenRendered) return;
              childrenRendered = true;

              if (isArray) {
                value.forEach((item, index) => {
                  const isLastChild = index === value.length - 1;
                  childrenElement.appendChild(
                    createNode(`[${index}]`, item, level + 1, true, isLastChild)
                  );
                });
              } else {
                const keys = Object.keys(value);
                keys.forEach((subKey, index) => {
                  const isLastChild = index === keys.length - 1;
                  childrenElement.appendChild(
                    createNode(
                      subKey,
                      value[subKey],
                      level + 1,
                      false,
                      isLastChild
                    )
                  );
                });
              }

              // Add closing bracket
              const closingElement = document.createElement("div");
              closingElement.className = "json-node-content";
              const closingBracket = document.createElement("span");
              closingBracket.style.color = "#6b7280";
              closingBracket.style.fontWeight = "500";
              closingBracket.textContent = isArray ? "]" : "}";

              const emptyToggle = document.createElement("span");
              emptyToggle.className = "json-toggle leaf";
              closingElement.appendChild(emptyToggle);
              closingElement.appendChild(closingBracket);

              if (!isLast) {
                const comma = document.createElement("span");
                comma.className = "json-separator";
                comma.textContent = ",";
                closingElement.appendChild(comma);
              }

              childrenElement.appendChild(closingElement);
            };

            // Toggle functionality
            toggle.addEventListener("click", () => {
              const isExpanded = childrenElement.classList.contains("expanded");
              if (isExpanded) {
                childrenElement.classList.remove("expanded");
                toggle.classList.remove("expanded");
                toggle.classList.add("collapsed");
              } else {
                renderChildren(); // Lazy render on first expand
                childrenElement.classList.add("expanded");
                toggle.classList.remove("collapsed");
                toggle.classList.add("expanded");
              }
            });

            // Auto-expand only first level for better performance
            if (level < 1) {
              renderChildren();
              childrenElement.classList.add("expanded");
              toggle.classList.remove("collapsed");
              toggle.classList.add("expanded");
            }
          } else {
            // Leaf node
            toggle.className += " leaf";

            const keyElement = document.createElement("span");
            if (isArrayItem) {
              keyElement.className = "json-array-index";
              keyElement.textContent = key;
            } else if (key) {
              keyElement.className = "json-key";
              keyElement.textContent = `"${key}"`;
            }

            const separator = document.createElement("span");
            separator.className = "json-separator";
            separator.textContent = ":";

            const valueElement = document.createElement("span");
            valueElement.className = "json-value";

            let type = typeof value;
            if (value === null) type = "null";
            valueElement.classList.add(type);

            if (type === "string") {
              valueElement.textContent = `"${value}"`;
            } else {
              valueElement.textContent = String(value);
            }

            contentElement.appendChild(toggle);
            if (key) {
              contentElement.appendChild(keyElement);
              contentElement.appendChild(separator);
              contentElement.appendChild(document.createTextNode(" "));
            }
            contentElement.appendChild(valueElement);

            if (!isLast) {
              const comma = document.createElement("span");
              comma.className = "json-separator";
              comma.textContent = ",";
              contentElement.appendChild(comma);
            }

            nodeElement.appendChild(contentElement);
          }

          return nodeElement;
        }
      });
    </script>
  </body>
</html>
